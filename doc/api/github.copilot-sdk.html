<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>github.copilot-sdk documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="API.html"><div class="inner"><span>API Reference</span></div></a></li><li class="depth-1 "><a href="byok.html"><div class="inner"><span>BYOK (Bring Your Own Key)</span></div></a></li><li class="depth-1 "><a href="debugging.html"><div class="inner"><span>MCP Server Debugging Guide</span></div></a></li><li class="depth-1 "><a href="getting-started.html"><div class="inner"><span>Getting Started with the Copilot SDK for Clojure</span></div></a></li><li class="depth-1 "><a href="index.html"><div class="inner"><span>Authentication</span></div></a></li><li class="depth-1 "><a href="index.html"><div class="inner"><span>Documentation</span></div></a></li><li class="depth-1 "><a href="overview.html"><div class="inner"><span>Using MCP Servers with the Copilot SDK for Clojure</span></div></a></li><li class="depth-1 "><a href="style.html"><div class="inner"><span>Documentation Style Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>github</span></div></div></li><li class="depth-2 current"><a href="github.copilot-sdk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>copilot-sdk</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.helpers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>helpers</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.instrument.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>instrument</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.logging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>logging</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.process.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>process</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.tools.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tools</span></div></a></li><li class="depth-3"><a href="github.copilot-sdk.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="github.copilot-sdk.html#var-.3Csend.21"><div class="inner"><span>&lt;send!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-abort.21"><div class="inner"><span>abort!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-assistant-events"><div class="inner"><span>assistant-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-client"><div class="inner"><span>client</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-client-options"><div class="inner"><span>client-options</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-create-session"><div class="inner"><span>create-session</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-define-tool"><div class="inner"><span>define-tool</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-delete-session.21"><div class="inner"><span>delete-session!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-destroy.21"><div class="inner"><span>destroy!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-event-types"><div class="inner"><span>event-types</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-events"><div class="inner"><span>events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-events-.3Echan"><div class="inner"><span>events-&gt;chan</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-evt"><div class="inner"><span>evt</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-force-stop.21"><div class="inner"><span>force-stop!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-get-auth-status"><div class="inner"><span>get-auth-status</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-get-foreground-session-id"><div class="inner"><span>get-foreground-session-id</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-get-last-session-id"><div class="inner"><span>get-last-session-id</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-get-messages"><div class="inner"><span>get-messages</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-get-status"><div class="inner"><span>get-status</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-list-models"><div class="inner"><span>list-models</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-list-sessions"><div class="inner"><span>list-sessions</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-notifications"><div class="inner"><span>notifications</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-on-lifecycle-event"><div class="inner"><span>on-lifecycle-event</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-ping"><div class="inner"><span>ping</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-result-denied"><div class="inner"><span>result-denied</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-result-failure"><div class="inner"><span>result-failure</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-result-rejected"><div class="inner"><span>result-rejected</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-result-success"><div class="inner"><span>result-success</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-resume-session"><div class="inner"><span>resume-session</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-send.21"><div class="inner"><span>send!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-send-and-wait.21"><div class="inner"><span>send-and-wait!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-send-async"><div class="inner"><span>send-async</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-send-async-with-id"><div class="inner"><span>send-async-with-id</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-session-config"><div class="inner"><span>session-config</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-session-events"><div class="inner"><span>session-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-session-id"><div class="inner"><span>session-id</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-set-foreground-session-id.21"><div class="inner"><span>set-foreground-session-id!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-start.21"><div class="inner"><span>start!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-state"><div class="inner"><span>state</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-stop.21"><div class="inner"><span>stop!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-subscribe-events"><div class="inner"><span>subscribe-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-tool-events"><div class="inner"><span>tool-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-unsubscribe-events"><div class="inner"><span>unsubscribe-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-with-client"><div class="inner"><span>with-client</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-with-client-session"><div class="inner"><span>with-client-session</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-with-session"><div class="inner"><span>with-session</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.html#var-workspace-path"><div class="inner"><span>workspace-path</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">github.copilot-sdk</h1><div class="doc"><div class="markdown"><p>Clojure SDK for programmatic control of GitHub Copilot CLI via JSON-RPC.</p>
<p>Quick Start:</p>
<pre><code class="language-clojure">(require '[github.copilot-sdk :as copilot])

;; Create and start client
(def client (copilot/client {:log-level :info}))
(copilot/start! client)

;; Create a session
(def session (copilot/create-session client {:model "gpt-5.2"}))

;; Send a message and wait for response
(def response (copilot/send-and-wait! session {:prompt "What is 2+2?"}))
(println (get-in response [:data :content]))

;; Clean up
(copilot/destroy! session)
(copilot/stop! client)
</code></pre>
</div></div><div class="public anchor" id="var-.3Csend.21"><h3>&lt;send!</h3><div class="usage"><code>(&lt;send! session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message and return a channel that delivers the final content string. This is the async equivalent of send-and-wait! - use inside go blocks.</p>
<p>Example:</p>
<pre><code class="language-clojure">(go
  (let [answer (&lt;! (copilot/&lt;send! session {:prompt "What is 2+2?"}))]
    (println answer)))
</code></pre>
</div></div></div><div class="public anchor" id="var-abort.21"><h3>abort!</h3><div class="usage"><code>(abort! session)</code></div><div class="doc"><div class="markdown"><p>Abort the currently processing message in this session.</p>
</div></div></div><div class="public anchor" id="var-assistant-events"><h3>assistant-events</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Assistant response events.</p>
</div></div></div><div class="public anchor" id="var-client"><h3>client</h3><div class="usage"><code>(client)</code><code>(client opts)</code></div><div class="doc"><div class="markdown"><p>Create a new CopilotClient.</p>
<p>Options: - :cli-path      - Path to CLI executable (default: “copilot”) - :cli-args      - Extra arguments for CLI - :cli-url       - URL of existing server (e.g., “localhost:8080”) - :cwd           - Working directory for CLI process - :port          - TCP port (default: 0 for random) - :use-stdio?    - Use stdio transport (default: true) - :log-level     - :none :error :warning :info :debug :all - :auto-start?   - Auto-start on first use (default: true) - :auto-restart? - Auto-restart on crash (default: true) - :env           - Environment variables map</p>
<p>Example:</p>
<pre><code class="language-clojure">(def client (copilot/client {:log-level :debug}))
</code></pre>
</div></div></div><div class="public anchor" id="var-client-options"><h3>client-options</h3><div class="usage"><code>(client-options client)</code></div><div class="doc"><div class="markdown"><p>Get the options used to create this client.</p>
<p>Returns the user-provided options merged with defaults. This reflects what the SDK is configured to use, not necessarily server state.</p>
<p>Example:</p>
<pre><code class="language-clojure">(copilot/client-options client)
;=&gt; {:log-level :info, :use-stdio? true, ...}
</code></pre>
</div></div></div><div class="public anchor" id="var-create-session"><h3>create-session</h3><div class="usage"><code>(create-session client)</code><code>(create-session client config)</code></div><div class="doc"><div class="markdown"><p>Create a new conversation session.</p>
<p>Config options: - :session-id           - Custom session ID - :model                - Model to use (e.g., “gpt-5.2”, “claude-sonnet-4.5”) - :tools                - Vector of tool definitions (use define-tool) - :system-message       - {:mode :append/:replace :content “…”} - :available-tools      - List of allowed tool names - :excluded-tools       - List of excluded tool names - :provider             - Custom provider config (BYOK) - :on-permission-request - Permission handler function Must return a map compatible with the permission result payload. The SDK wraps this into the JSON-RPC response as {:result <your-map>}: {:kind :approved} {:kind :denied-by-rules :rules <a href="{:kind &quot;shell&quot; :argument &quot;echo hi&quot;}">{:kind “shell” :argument “echo hi”}</a>} {:kind :denied-no-approval-rule-and-could-not-request-from-user} {:kind :denied-interactively-by-user :feedback “optional”} - :streaming?           - Enable streaming deltas - :mcp-servers          - MCP server configs map (keyed by server ID) - :custom-agents        - Custom agent configs - :config-dir           - Override config directory for CLI (configDir) - :skill-directories    - Additional skill directories to load - :disabled-skills      - Disable specific skills by name - :large-output         - (Experimental) Tool output handling config {:enabled :max-size-bytes :output-dir} Note: CLI protocol feature, not in official SDK. outputDir may be ignored. - :working-directory    - Working directory for the session (tool operations relative to this)</your-map></p>
<p>Example:</p>
<pre><code class="language-clojure">(def session (copilot/create-session client {:model "gpt-5.2"}))
</code></pre>
</div></div></div><div class="public anchor" id="var-define-tool"><h3>define-tool</h3><div class="usage"><code>(define-tool name opts)</code></div><div class="doc"><div class="markdown"><p>Define a tool with a handler function.</p>
<p>Arguments: - name        - Tool name (string) - opts map: - :description - Tool description - :parameters  - JSON schema for parameters - :handler     - Function (fn <a href="args invocation">args invocation</a> -&gt; result)</p>
<p>The handler receives: - args       - The parsed arguments from the LLM - invocation - Map with :session-id, :tool-call-id, :tool-name, :arguments</p>
<p>Returns: a tool definition map</p>
<p>Example:</p>
<pre><code class="language-clojure">(def weather-tool
  (copilot/define-tool "get_weather"
    {:description "Get weather for a location"
     :parameters {:type "object"
                  :properties {:location {:type "string"}}
                  :required ["location"]}
     :handler (fn [args _]
                (str "Weather in " (:location args) ": Sunny"))}))

(def session (copilot/create-session client {:tools [weather-tool]}))
</code></pre>
</div></div></div><div class="public anchor" id="var-delete-session.21"><h3>delete-session!</h3><div class="usage"><code>(delete-session! client session-id)</code></div><div class="doc"><div class="markdown"><p>Delete a session and its data from disk.</p>
</div></div></div><div class="public anchor" id="var-destroy.21"><h3>destroy!</h3><div class="usage"><code>(destroy! session)</code></div><div class="doc"><div class="markdown"><p>Destroy the session and free resources.</p>
</div></div></div><div class="public anchor" id="var-event-types"><h3>event-types</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>All valid session event types as namespaced keywords.</p>
</div></div></div><div class="public anchor" id="var-events"><h3>events</h3><div class="usage"><code>(events session)</code></div><div class="doc"><div class="markdown"><p>Get the event mult for this session. Use tap/untap to subscribe:</p>
<p>Example:</p>
<pre><code class="language-clojure">(require '[clojure.core.async :refer [chan tap untap go-loop &lt;!]])

(let [ch (chan 100)]
  (tap (copilot/events session) ch)
  (go-loop []
    (when-let [event (&lt;! ch)]
      (println "Event:" (:type event))
      (recur))))
</code></pre>
<p>Remember to untap and close your channel when done.</p>
</div></div></div><div class="public anchor" id="var-events-.3Echan"><h3>events-&gt;chan</h3><div class="usage"><code>(events-&gt;chan session)</code><code>(events-&gt;chan session opts)</code></div><div class="doc"><div class="markdown"><p>Subscribe to session events with options.</p>
<p>Options: - :buffer - Channel buffer size (default 1024) - :xf     - Transducer applied to events</p>
<p>Drop behavior: If this subscriber’s buffer is full when mult delivers an event, that specific event is silently dropped for this subscriber only. Other subscribers with available buffer space still receive the event.</p>
</div></div></div><div class="public anchor" id="var-evt"><h3>evt</h3><div class="usage"><code>(evt k)</code></div><div class="doc"><div class="markdown"><p>Convert an unqualified event keyword to a namespace-qualified event keyword.</p>
<p>Example:</p>
<pre><code class="language-clojure">(evt :session.info)      ;=&gt; :copilot/session.info
(evt :assistant.message) ;=&gt; :copilot/assistant.message
</code></pre>
<p>Throws IllegalArgumentException if the keyword is not a valid event type.</p>
</div></div></div><div class="public anchor" id="var-force-stop.21"><h3>force-stop!</h3><div class="usage"><code>(force-stop! client)</code></div><div class="doc"><div class="markdown"><p>Force stop the CLI server without graceful cleanup. Use when stop! takes too long.</p>
</div></div></div><div class="public anchor" id="var-get-auth-status"><h3>get-auth-status</h3><div class="usage"><code>(get-auth-status client)</code></div><div class="doc"><div class="markdown"><p>Get current authentication status. Returns {:authenticated? :auth-type :host :login :status-message}.</p>
<p>Example:</p>
<pre><code class="language-clojure">(let [{:keys [authenticated? login]} (copilot/get-auth-status client)]
  (if authenticated?
    (println "Logged in as" login)
    (println "Not authenticated")))
</code></pre>
</div></div></div><div class="public anchor" id="var-get-foreground-session-id"><h3>get-foreground-session-id</h3><div class="usage"><code>(get-foreground-session-id client)</code></div><div class="doc"><div class="markdown"><p>Get the foreground session ID (TUI+server mode). Returns the session ID or nil if none.</p>
</div></div></div><div class="public anchor" id="var-get-last-session-id"><h3>get-last-session-id</h3><div class="usage"><code>(get-last-session-id client)</code></div><div class="doc"><div class="markdown"><p>Get the ID of the most recently updated session.</p>
</div></div></div><div class="public anchor" id="var-get-messages"><h3>get-messages</h3><div class="usage"><code>(get-messages session)</code></div><div class="doc"><div class="markdown"><p>Get all events/messages from this session’s history.</p>
</div></div></div><div class="public anchor" id="var-get-status"><h3>get-status</h3><div class="usage"><code>(get-status client)</code></div><div class="doc"><div class="markdown"><p>Get CLI status including version and protocol information. Returns {:version :protocol-version}.</p>
<p>Example:</p>
<pre><code class="language-clojure">(let [{:keys [version protocol-version]} (copilot/get-status client)]
  (println "CLI version:" version "protocol:" protocol-version))
</code></pre>
</div></div></div><div class="public anchor" id="var-list-models"><h3>list-models</h3><div class="usage"><code>(list-models client)</code></div><div class="doc"><div class="markdown"><p>List available models with their metadata. Requires authentication.</p>
<p>Returns a vector of model info maps with keys: :id :name :vendor :family :version :max-input-tokens :max-output-tokens :preview? :default-temperature :model-picker-priority :model-policy :vision-limits {:supported-media-types :max-prompt-images :max-prompt-image-size}</p>
<p>Example:</p>
<pre><code class="language-clojure">(doseq [model (copilot/list-models client)]
  (println (:name model) "-" (:id model)))
</code></pre>
</div></div></div><div class="public anchor" id="var-list-sessions"><h3>list-sessions</h3><div class="usage"><code>(list-sessions client)</code></div><div class="doc"><div class="markdown"><p>List all available sessions. Returns a vector of session metadata maps: {:session-id :start-time :modified-time :summary :remote?}</p>
</div></div></div><div class="public anchor" id="var-notifications"><h3>notifications</h3><div class="usage"><code>(notifications client)</code></div><div class="doc"><div class="markdown"><p>Get the channel that receives non-session notifications. Notifications are dropped if the channel is full.</p>
</div></div></div><div class="public anchor" id="var-on-lifecycle-event"><h3>on-lifecycle-event</h3><div class="usage"><code>(on-lifecycle-event client handler)</code><code>(on-lifecycle-event client event-type handler)</code></div><div class="doc"><div class="markdown"><p>Subscribe to session lifecycle events.</p>
<p>Two arities: (on-lifecycle-event client handler) Subscribe to ALL lifecycle events. Handler receives an event map with keys :lifecycle-event-type, :session-id, and optionally :metadata.</p>
<p>(on-lifecycle-event client event-type handler) Subscribe to a specific event type only. event-type is one of: :session.created :session.deleted :session.updated :session.foreground :session.background</p>
<p>Returns an unsubscribe function (call with no args to remove the handler).</p>
<p>Example:</p>
<pre><code class="language-clojure">;; All events
(def unsub (copilot/on-lifecycle-event client
             (fn [event]
               (println (:lifecycle-event-type event) (:session-id event)))))

;; Specific event type
(def unsub (copilot/on-lifecycle-event client :session.created
             (fn [event]
               (println "New session:" (:session-id event)))))

;; Unsubscribe
(unsub)
</code></pre>
</div></div></div><div class="public anchor" id="var-ping"><h3>ping</h3><div class="usage"><code>(ping client)</code><code>(ping client message)</code></div><div class="doc"><div class="markdown"><p>Ping the server to check connectivity. Returns {:message :timestamp :protocol-version}</p>
</div></div></div><div class="public anchor" id="var-result-denied"><h3>result-denied</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-result-failure"><h3>result-failure</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-result-rejected"><h3>result-rejected</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-result-success"><h3>result-success</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-resume-session"><h3>resume-session</h3><div class="usage"><code>(resume-session client session-id)</code><code>(resume-session client session-id config)</code></div><div class="doc"><div class="markdown"><p>Resume an existing session by ID. Accepts the same config options as <code>create-session</code> (except <code>:session-id</code>), plus: - :disable-resume?  - When true, skip emitting the session.resume event (default: false)</p>
<p>Example:</p>
<pre><code class="language-clojure">(def session (copilot/resume-session client "session-123"))
;; Resume with different model
(def session (copilot/resume-session client "session-123"
               {:model "claude-sonnet-4"
                :reasoning-effort "high"}))
</code></pre>
</div></div></div><div class="public anchor" id="var-send.21"><h3>send!</h3><div class="usage"><code>(send! session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message to the session (fire-and-forget). Returns the message ID immediately.</p>
<p>Options: - :prompt       - The message text (required) - :attachments  - Vector of {:type :file/:directory :path “…” :display-name “…”} - :mode         - :enqueue (default) or :immediate</p>
<p>Example:</p>
<pre><code class="language-clojure">(copilot/send! session {:prompt "Hello!"})
</code></pre>
</div></div></div><div class="public anchor" id="var-send-and-wait.21"><h3>send-and-wait!</h3><div class="usage"><code>(send-and-wait! session opts)</code><code>(send-and-wait! session opts timeout-ms)</code></div><div class="doc"><div class="markdown"><p>Send a message and wait until the session becomes idle. Returns the final assistant message event, or nil if none received. Serialized per session to avoid mixing concurrent sends.</p>
<p>Options: same as send!, plus: - :timeout-ms   - Timeout in milliseconds (default: 180000)</p>
<p>Example:</p>
<pre><code class="language-clojure">(let [response (copilot/send-and-wait! session {:prompt "What is 2+2?"})]
  (println (get-in response [:data :content])))
</code></pre>
</div></div></div><div class="public anchor" id="var-send-async"><h3>send-async</h3><div class="usage"><code>(send-async session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message and return a core.async channel that receives events. The channel closes after session.idle or session.error. Serialized per session to avoid mixing concurrent sends.</p>
<p>Example:</p>
<pre><code class="language-clojure">(let [ch (copilot/send-async session {:prompt "Tell me a story"})]
  (go-loop []
    (when-let [event (&lt;! ch)]
      (println (:type event))
      (recur))))
</code></pre>
</div></div></div><div class="public anchor" id="var-send-async-with-id"><h3>send-async-with-id</h3><div class="usage"><code>(send-async-with-id session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message and return {:message-id :events-ch}.</p>
</div></div></div><div class="public anchor" id="var-session-config"><h3>session-config</h3><div class="usage"><code>(session-config session)</code></div><div class="doc"><div class="markdown"><p>Get the configuration that was passed to create this session.</p>
<p>Returns the user-provided config map. This reflects what was requested, not necessarily what the server is using (e.g., if a model was unavailable, the server may have selected a different one).</p>
<p>The session.start event contains the actual selected model if validation is needed.</p>
<p>Example:</p>
<pre><code class="language-clojure">(copilot/session-config session)
;=&gt; {:model "gpt-5.2", :streaming? true, ...}
</code></pre>
</div></div></div><div class="public anchor" id="var-session-events"><h3>session-events</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Session lifecycle and state management events.</p>
</div></div></div><div class="public anchor" id="var-session-id"><h3>session-id</h3><div class="usage"><code>(session-id session)</code></div><div class="doc"><div class="markdown"><p>Get the session ID.</p>
</div></div></div><div class="public anchor" id="var-set-foreground-session-id.21"><h3>set-foreground-session-id!</h3><div class="usage"><code>(set-foreground-session-id! client session-id)</code></div><div class="doc"><div class="markdown"><p>Set the foreground session (TUI+server mode). Requests the TUI to switch to displaying the specified session.</p>
</div></div></div><div class="public anchor" id="var-start.21"><h3>start!</h3><div class="usage"><code>(start! client)</code></div><div class="doc"><div class="markdown"><p>Start the CLI server and establish connection. Blocks until connected or throws on error.</p>
<p>Example:</p>
<pre><code class="language-clojure">(copilot/start! client)
</code></pre>
</div></div></div><div class="public anchor" id="var-state"><h3>state</h3><div class="usage"><code>(state client)</code></div><div class="doc"><div class="markdown"><p>Get the current connection state. Returns :disconnected | :connecting | :connected | :error</p>
</div></div></div><div class="public anchor" id="var-stop.21"><h3>stop!</h3><div class="usage"><code>(stop! client)</code></div><div class="doc"><div class="markdown"><p>Stop the CLI server and close all sessions. Returns a vector of any errors encountered during cleanup.</p>
<p>Example:</p>
<pre><code class="language-clojure">(let [errors (copilot/stop! client)]
  (when (seq errors)
    (println "Cleanup errors:" errors)))
</code></pre>
</div></div></div><div class="public anchor" id="var-subscribe-events"><h3>subscribe-events</h3><div class="usage"><code>(subscribe-events session)</code></div><div class="doc"><div class="markdown"><p>Subscribe to session events. Returns a channel (buffer 1024) that receives events. The channel receives nil (close) when the session is destroyed. For explicit cleanup, call unsubscribe-events.</p>
<p>This is a convenience wrapper around (tap (copilot/events session) ch).</p>
<p>Drop behavior: Events are delivered via core.async mult. If this subscriber’s buffer is full when mult delivers an event, that specific event is silently dropped for this subscriber only. Other subscribers with available buffer space still receive the event. With 1024 buffer, drops are unlikely unless the subscriber stops reading entirely.</p>
<p>Example:</p>
<pre><code class="language-clojure">(let [ch (copilot/subscribe-events session)]
  (go-loop []
    (when-let [event (&lt;! ch)]
      (println "Event:" (:type event))
      (recur))))
</code></pre>
</div></div></div><div class="public anchor" id="var-tool-events"><h3>tool-events</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Tool execution events.</p>
</div></div></div><div class="public anchor" id="var-unsubscribe-events"><h3>unsubscribe-events</h3><div class="usage"><code>(unsubscribe-events session ch)</code></div><div class="doc"><div class="markdown"><p>Unsubscribe a channel from session events.</p>
</div></div></div><div class="public anchor" id="var-with-client"><h3>with-client</h3><h4 class="type">macro</h4><div class="usage"><code>(with-client [client-sym &amp; [opts]] &amp; body)</code></div><div class="doc"><div class="markdown"><p>Create a client, start it, and ensure stop! on exit.</p>
<p>Usage: (with-client <a href="c {:log-level :info}">c {:log-level :info}</a> …)</p>
</div></div></div><div class="public anchor" id="var-with-client-session"><h3>with-client-session</h3><h4 class="type">macro</h4><div class="usage"><code>(with-client-session [a b &amp; more] &amp; body)</code></div><div class="doc"><div class="markdown"><p>Create a client + session and ensure cleanup on exit. Automatically calls destroy! on session and stop! on client.</p>
<p>Four forms are supported:</p>
<ol>
<li><a href="session session-opts">session session-opts</a> - anonymous client with default options</li>
</ol>
<pre><code class="language-clojure">(with-client-session [session {:model "gpt-5.2"}]
  (copilot/send! session {:prompt "Hi"}))
</code></pre>
<ol>
<li><a href="client-opts session session-opts">client-opts session session-opts</a> - anonymous client with custom options</li>
</ol>
<pre><code class="language-clojure">(with-client-session [{:log-level :debug} session {:model "gpt-5.2"}]
  (copilot/send! session {:prompt "Hi"}))
</code></pre>
<ol>
<li><a href="client session session-opts">client session session-opts</a> - named client with default options</li>
</ol>
<pre><code class="language-clojure">(with-client-session [client session {:model "gpt-5.2"}]
  (println (copilot/client-options client))
  (copilot/send! session {:prompt "Hi"}))
</code></pre>
<ol>
<li><a href="client client-opts session session-opts">client client-opts session session-opts</a> - named client with custom options</li>
</ol>
<pre><code class="language-clojure">(with-client-session [client {:log-level :debug} session {:model "gpt-5.2"}]
  (println (copilot/client-options client))
  (copilot/send! session {:prompt "Hi"}))
</code></pre>
</div></div></div><div class="public anchor" id="var-with-session"><h3>with-session</h3><h4 class="type">macro</h4><div class="usage"><code>(with-session [session-sym client &amp; [config]] &amp; body)</code></div><div class="doc"><div class="markdown"><p>Create a session and ensure destroy! on exit.</p>
<p>Usage: (with-session <a href="s client {:model &quot;gpt-5.2&quot;}">s client {:model “gpt-5.2”}</a> …)</p>
</div></div></div><div class="public anchor" id="var-workspace-path"><h3>workspace-path</h3><div class="usage"><code>(workspace-path session)</code></div><div class="doc"><div class="markdown"><p>Get the session workspace path when provided by the CLI.</p>
</div></div></div></div></body></html>