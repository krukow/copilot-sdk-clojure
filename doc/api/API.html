<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>API Reference</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="API.html"><div class="inner"><span>API Reference</span></div></a></li><li class="depth-1 "><a href="byok.html"><div class="inner"><span>BYOK (Bring Your Own Key)</span></div></a></li><li class="depth-1 "><a href="debugging.html"><div class="inner"><span>MCP Server Debugging Guide</span></div></a></li><li class="depth-1 "><a href="getting-started.html"><div class="inner"><span>Getting Started with the Copilot SDK for Clojure</span></div></a></li><li class="depth-1 "><a href="index.html"><div class="inner"><span>Authentication</span></div></a></li><li class="depth-1 "><a href="index.html"><div class="inner"><span>Documentation</span></div></a></li><li class="depth-1 "><a href="overview.html"><div class="inner"><span>Using MCP Servers with the Copilot SDK for Clojure</span></div></a></li><li class="depth-1 "><a href="style.html"><div class="inner"><span>Documentation Style Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>github</span></div></div></li><li class="depth-2"><a href="github.copilot-sdk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>copilot-sdk</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.helpers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>helpers</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.instrument.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>instrument</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.logging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>logging</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.process.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>process</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.tools.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tools</span></div></a></li><li class="depth-3"><a href="github.copilot-sdk.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#api-reference" id="api-reference"></a>API Reference</h1>
<h2><a href="#helpers-api" id="helpers-api"></a>Helpers API</h2>
<p>The helpers namespace provides simple, stateless query functions with automatic client management.</p>
<pre><code class="language-clojure">(require '[github.copilot-sdk.helpers :as h])
</code></pre>
<h3><a href="#query" id="query"></a><code>query</code></h3>
<pre><code class="language-clojure">(h/query prompt &amp; {:keys [client session timeout-ms]})
</code></pre>
<p>Execute a query and return the response text.</p>
<p><strong>Options:</strong> - <code>:client</code> - Client options map (cli-path, log-level, cwd, env) OR a CopilotClient instance - <code>:session</code> - Session options map (model, system-prompt, tools, etc.) OR a CopilotSession instance - <code>:timeout-ms</code> - Timeout in milliseconds (default: 180000)</p>
<p>When <code>:session</code> is a CopilotSession instance, the query uses that session directly (enabling multi-turn conversations). When <code>:client</code> is a CopilotClient instance, it uses that client directly.</p>
<pre><code class="language-clojure">;; Simple query (shared client, fresh session)
(h/query "What is 2+2?")
;; =&gt; "4"

;; With session options
(h/query "Explain monads" :session {:model "claude-sonnet-4.5"})

;; With system prompt
(h/query "Hello" :session {:system-prompt "Be concise."})

;; With explicit client
(copilot/with-client [client {}]
  (h/query "What is Clojure?" :client client))

;; With explicit session (multi-turn conversation)
(copilot/with-client [client {}]
  (copilot/with-session [session client {}]
    (h/query "My name is Alice." :session session)
    (h/query "What is my name?" :session session))) ;; context preserved!
</code></pre>
<h3><a href="#query-seq" id="query-seq"></a><code>query-seq!</code></h3>
<pre><code class="language-clojure">(h/query-seq! prompt &amp; {:keys [client session max-events]})
</code></pre>
<p>Execute a query and return a bounded lazy sequence of events with guaranteed cleanup (default: 256 events).</p>
<pre><code class="language-clojure">(-&gt;&gt; (h/query-seq! "Tell me a story" :session {:streaming? true})
     (filter #(= :copilot/assistant.message_delta (:type %)))
     (map #(get-in % [:data :delta-content]))
     (run! print))
</code></pre>
<h3><a href="#query-chan" id="query-chan"></a><code>query-chan</code></h3>
<pre><code class="language-clojure">(h/query-chan prompt &amp; {:keys [client session buffer]})
</code></pre>
<p>Execute a query and return a core.async channel of events. Use this when you need an explicit lifecycle or want to stop reading early without leaking session resources.</p>
<pre><code class="language-clojure">(let [ch (h/query-chan "Tell me a story" :session {:streaming? true})]
  (go-loop []
    (when-let [event (&lt;! ch)]
      (when (= :copilot/assistant.message_delta (:type event))
        (print (get-in event [:data :delta-content])))
      (recur))))
</code></pre>
<h3><a href="#shutdown" id="shutdown"></a><code>shutdown!</code></h3>
<pre><code class="language-clojure">(h/shutdown!)
</code></pre>
<p>Explicitly shutdown the shared client. Safe to call multiple times.</p>
<hr />
<h2><a href="#copilotclient" id="copilotclient"></a>CopilotClient</h2>
<pre><code class="language-clojure">(require '[github.copilot-sdk :as copilot])
</code></pre>
<h3><a href="#constructor" id="constructor"></a>Constructor</h3>
<pre><code class="language-clojure">(copilot/client options)
</code></pre>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr><th> Key </th><th> Type </th><th> Default </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:cli-path</code> </td><td> string </td><td> <code>"copilot"</code> </td><td> Path to CLI executable </td></tr>
<tr><td> <code>:cli-args</code> </td><td> vector </td><td> <code>[]</code> </td><td> Extra arguments prepended before SDK-managed flags </td></tr>
<tr><td> <code>:cli-url</code> </td><td> string </td><td> nil </td><td> URL of existing CLI server (e.g., <code>"localhost:8080"</code>). When provided, no CLI process is spawned </td></tr>
<tr><td> <code>:port</code> </td><td> number </td><td> <code>0</code> </td><td> Server port (0 = random) </td></tr>
<tr><td> <code>:use-stdio?</code> </td><td> boolean </td><td> <code>true</code> </td><td> Use stdio transport instead of TCP </td></tr>
<tr><td> <code>:log-level</code> </td><td> keyword </td><td> <code>:info</code> </td><td> One of <code>:none</code> <code>:error</code> <code>:warning</code> <code>:info</code> <code>:debug</code> <code>:all</code> </td></tr>
<tr><td> <code>:auto-start?</code> </td><td> boolean </td><td> <code>true</code> </td><td> Auto-start server on first operation </td></tr>
<tr><td> <code>:auto-restart?</code> </td><td> boolean </td><td> <code>true</code> </td><td> Auto-restart on crash </td></tr>
<tr><td> <code>:notification-queue-size</code> </td><td> number </td><td> <code>4096</code> </td><td> Max queued protocol notifications </td></tr>
<tr><td> <code>:router-queue-size</code> </td><td> number </td><td> <code>4096</code> </td><td> Max queued non-session notifications </td></tr>
<tr><td> <code>:tool-timeout-ms</code> </td><td> number </td><td> <code>120000</code> </td><td> Timeout for tool handlers returning channels </td></tr>
<tr><td> <code>:cwd</code> </td><td> string </td><td> nil </td><td> Working directory for CLI process </td></tr>
<tr><td> <code>:env</code> </td><td> map </td><td> nil </td><td> Environment variables </td></tr>
<tr><td> <code>:github-token</code> </td><td> string </td><td> nil </td><td> GitHub token for authentication. Sets <code>COPILOT_SDK_AUTH_TOKEN</code> env var and passes <code>--auth-token-env</code> flag </td></tr>
<tr><td> <code>:use-logged-in-user?</code> </td><td> boolean </td><td> <code>true</code> </td><td> Use logged-in user auth. Defaults to <code>false</code> when <code>:github-token</code> is provided. Cannot be used with <code>:cli-url</code> </td></tr>
</tbody>
</table>
<h3><a href="#methods" id="methods"></a>Methods</h3>
<h4><a href="#start" id="start"></a><code>start!</code></h4>
<pre><code class="language-clojure">(copilot/start! client)
</code></pre>
<p>Start the CLI server and establish connection. Blocks until connected.</p>
<h4><a href="#with-client" id="with-client"></a><code>with-client</code></h4>
<pre><code class="language-clojure">(copilot/with-client [client {:log-level :info}]
  ;; use client
  )
</code></pre>
<p>Create a client, start it, and ensure <code>stop!</code> runs on exit.</p>
<h4><a href="#stop" id="stop"></a><code>stop!</code></h4>
<pre><code class="language-clojure">(copilot/stop! client)
</code></pre>
<p>Stop the server and close all sessions gracefully.</p>
<h4><a href="#force-stop" id="force-stop"></a><code>force-stop!</code></h4>
<pre><code class="language-clojure">(copilot/force-stop! client)
</code></pre>
<p>Force stop the CLI server without graceful cleanup. Use when <code>stop!</code> takes too long.</p>
<h4><a href="#client-options" id="client-options"></a><code>client-options</code></h4>
<pre><code class="language-clojure">(copilot/client-options client)
;; =&gt; {:log-level :info, :use-stdio? true, :auto-start? true, ...}
</code></pre>
<p>Get the options that were used to create this client.</p>
<h4><a href="#create-session" id="create-session"></a><code>create-session</code></h4>
<pre><code class="language-clojure">(copilot/create-session client config)
</code></pre>
<p>Create a new conversation session.</p>
<h4><a href="#with-session" id="with-session"></a><code>with-session</code></h4>
<pre><code class="language-clojure">(copilot/with-session [session client {:model "gpt-5.2"}]
  ;; use session
  )
</code></pre>
<p>Create a session and ensure <code>destroy!</code> runs on exit.</p>
<h4><a href="#with-client-session" id="with-client-session"></a><code>with-client-session</code></h4>
<pre><code class="language-clojure">;; Form 1: [session session-opts] - anonymous client with default options
(copilot/with-client-session [session {:model "gpt-5.2"}]
  ;; use session
  )

;; Form 2: [client-opts session session-opts] - anonymous client with custom options
(copilot/with-client-session [{:log-level :debug} session {:model "gpt-5.2"}]
  ;; use session
  )

;; Form 3: [client session session-opts] - named client with default options
(copilot/with-client-session [client session {:model "gpt-5.2"}]
  ;; use client and session
  )

;; Form 4: [client client-opts session session-opts] - named client with custom options
(copilot/with-client-session [client {:log-level :debug} session {:model "gpt-5.2"}]
  ;; use client and session
  )
</code></pre>
<p>Create a client and session together, ensuring both are cleaned up on exit.</p>
<p><strong>Config:</strong></p>
<table>
<thead>
<tr><th> Key </th><th> Type </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:session-id</code> </td><td> string </td><td> Custom session ID (optional) </td></tr>
<tr><td> <code>:model</code> </td><td> string </td><td> Model to use (<code>"gpt-5.2"</code>, <code>"claude-sonnet-4.5"</code>, etc.) </td></tr>
<tr><td> <code>:tools</code> </td><td> vector </td><td> Custom tools exposed to the CLI </td></tr>
<tr><td> <code>:system-message</code> </td><td> map </td><td> System message customization (see below) </td></tr>
<tr><td> <code>:available-tools</code> </td><td> vector </td><td> List of allowed tool names </td></tr>
<tr><td> <code>:excluded-tools</code> </td><td> vector </td><td> List of excluded tool names </td></tr>
<tr><td> <code>:provider</code> </td><td> map </td><td> Provider config for BYOK (see <a href="../auth/byok.html">BYOK docs</a>). Required key: <code>:base-url</code>. Optional: <code>:provider-type</code> (<code>:openai</code>/<code>:azure</code>/<code>:anthropic</code>), <code>:wire-api</code> (<code>:completions</code>/<code>:responses</code>), <code>:api-key</code>, <code>:bearer-token</code>, <code>:azure-options</code> </td></tr>
<tr><td> <code>:mcp-servers</code> </td><td> map </td><td> MCP server configs keyed by server ID (see <a href="../mcp/overview.html">MCP docs</a>). Local servers: <code>:mcp-command</code>, <code>:mcp-args</code>, <code>:mcp-tools</code>. Remote servers: <code>:mcp-server-type</code> (<code>:http</code>/<code>:sse</code>), <code>:mcp-url</code>, <code>:mcp-tools</code> </td></tr>
<tr><td> <code>:custom-agents</code> </td><td> vector </td><td> Custom agent configs </td></tr>
<tr><td> <code>:on-permission-request</code> </td><td> fn </td><td> Permission handler function </td></tr>
<tr><td> <code>:streaming?</code> </td><td> boolean </td><td> Enable streaming deltas </td></tr>
<tr><td> <code>:config-dir</code> </td><td> string </td><td> Override config directory for CLI </td></tr>
<tr><td> <code>:skill-directories</code> </td><td> vector </td><td> Additional skill directories to load </td></tr>
<tr><td> <code>:disabled-skills</code> </td><td> vector </td><td> Disable specific skills by name </td></tr>
<tr><td> <code>:large-output</code> </td><td> map </td><td> (Experimental) Tool output handling config. CLI protocol feature, not in official SDK. </td></tr>
<tr><td> <code>:working-directory</code> </td><td> string </td><td> Working directory for the session (tool operations relative to this) </td></tr>
<tr><td> <code>:infinite-sessions</code> </td><td> map </td><td> Infinite session config (see below) </td></tr>
<tr><td> <code>:reasoning-effort</code> </td><td> string </td><td> Reasoning effort level: <code>"low"</code>, <code>"medium"</code>, <code>"high"</code>, or <code>"xhigh"</code> </td></tr>
<tr><td> <code>:on-user-input-request</code> </td><td> fn </td><td> Handler for <code>ask_user</code> requests (see below) </td></tr>
<tr><td> <code>:hooks</code> </td><td> map </td><td> Lifecycle hooks (see below) </td></tr>
</tbody>
</table>
<h4><a href="#resume-session" id="resume-session"></a><code>resume-session</code></h4>
<pre><code class="language-clojure">(copilot/resume-session client session-id)
(copilot/resume-session client session-id config)
</code></pre>
<p>Resume an existing session by ID. The <code>config</code> map accepts the same options as <code>create-session</code> (except <code>:session-id</code>), plus:</p>
<table>
<thead>
<tr><th> Option </th><th> Type </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:disable-resume?</code> </td><td> boolean </td><td> When true, skip emitting the session.resume event (default: false) </td></tr>
</tbody>
</table>
<pre><code class="language-clojure">;; Resume with a different model and reasoning effort
(copilot/resume-session client "session-123"
  {:model "claude-sonnet-4"
   :reasoning-effort "high"})
</code></pre>
<h4><a href="#ping" id="ping"></a><code>ping</code></h4>
<pre><code class="language-clojure">(copilot/ping client)
(copilot/ping client message)
</code></pre>
<p>Ping the server to check connectivity. Returns <code>{:message "..." :timestamp ... :protocol-version ...}</code>.</p>
<h4><a href="#get-status" id="get-status"></a><code>get-status</code></h4>
<pre><code class="language-clojure">(copilot/get-status client)
</code></pre>
<p>Get CLI status including version and protocol information. Returns <code>{:version "0.0.389" :protocol-version 2}</code>.</p>
<h4><a href="#get-auth-status" id="get-auth-status"></a><code>get-auth-status</code></h4>
<pre><code class="language-clojure">(copilot/get-auth-status client)
</code></pre>
<p>Get current authentication status. Returns:</p>
<pre><code class="language-clojure">{:authenticated? true
 :auth-type :user        ; :user | :env | :gh-cli | :hmac | :api-key | :token
 :host "github.com"
 :login "username"
 :status-message "Authenticated as username"}
</code></pre>
<h4><a href="#list-models" id="list-models"></a><code>list-models</code></h4>
<pre><code class="language-clojure">(copilot/list-models client)
</code></pre>
<p>List available models with their metadata. Results are cached per client connection. Requires authentication. Returns a vector of model info maps:</p>
<pre><code class="language-clojure">[{:id "gpt-5.2"
  :name "GPT-5.2"
  :vendor "openai"
  :family "gpt-5.2"
  :version "gpt-5.2"
  :max-input-tokens 128000
  :max-output-tokens 16384
  :preview? false
  :model-capabilities {:model-supports {:supports-vision true
                                        :supports-reasoning-effort false}
                       :model-limits {:max-prompt-tokens 128000
                                      :max-context-window-tokens 128000
                                      :vision-capabilities
                                      {:supported-media-types ["image/png" "image/jpeg"]
                                       :max-prompt-images 10
                                       :max-prompt-image-size 20971520}}}
  :model-policy {:policy-state "enabled"
                 :terms "..."}
  :model-billing {:multiplier 1.0}
  ;; For models supporting reasoning:
  :supported-reasoning-efforts ["low" "medium" "high" "xhigh"]
  :default-reasoning-effort "medium"}
 ...]
</code></pre>
<h4><a href="#state" id="state"></a><code>state</code></h4>
<pre><code class="language-clojure">(copilot/state client)
</code></pre>
<p>Get current connection state: <code>:disconnected</code> | <code>:connecting</code> | <code>:connected</code> | <code>:error</code></p>
<h4><a href="#notifications" id="notifications"></a><code>notifications</code></h4>
<pre><code class="language-clojure">(copilot/notifications client)
</code></pre>
<p>Get a channel that receives non-session notifications. The channel is buffered; notifications are dropped if it fills.</p>
<h4><a href="#on-lifecycle-event" id="on-lifecycle-event"></a><code>on-lifecycle-event</code></h4>
<pre><code class="language-clojure">;; Subscribe to all lifecycle events
(def unsub (copilot/on-lifecycle-event client
             (fn [event]
               (println (:lifecycle-event-type event) (:session-id event)))))

;; Subscribe to a specific event type
(def unsub (copilot/on-lifecycle-event client :session.created
             (fn [event]
               (println "New session:" (:session-id event)))))

;; Unsubscribe
(unsub)
</code></pre>
<p>Subscribe to session lifecycle events dispatched by the CLI server. The handler receives an event map with:</p>
<table>
<thead>
<tr><th> Key </th><th> Type </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:lifecycle-event-type</code> </td><td> keyword </td><td> One of <code>:session.created</code>, <code>:session.deleted</code>, <code>:session.updated</code>, <code>:session.foreground</code>, <code>:session.background</code> </td></tr>
<tr><td> <code>:session-id</code> </td><td> string </td><td> The session ID </td></tr>
<tr><td> <code>:metadata</code> </td><td> map (optional) </td><td> Contains <code>:start-time</code>, <code>:modified-time</code>, and optionally <code>:summary</code> </td></tr>
</tbody>
</table>
<p><strong>Two arities:</strong> - <code>(on-lifecycle-event client handler)</code> — wildcard, receives all lifecycle events - <code>(on-lifecycle-event client event-type handler)</code> — receives only events matching <code>event-type</code></p>
<p>Returns an unsubscribe function. Call it with no arguments to remove the handler.</p>
<p>Handlers are called synchronously on the notification router’s go-loop. Keep handlers fast; offload heavy work to another thread or channel.</p>
<h4><a href="#list-sessions" id="list-sessions"></a><code>list-sessions</code></h4>
<pre><code class="language-clojure">(copilot/list-sessions client)
</code></pre>
<p>List all available sessions. Returns vector of session metadata with <code>:start-time</code> and <code>:modified-time</code> as <code>java.time.Instant</code>.</p>
<h4><a href="#delete-session" id="delete-session"></a><code>delete-session!</code></h4>
<pre><code class="language-clojure">(copilot/delete-session! client session-id)
</code></pre>
<p>Delete a session and its data from disk.</p>
<h4><a href="#get-last-session-id" id="get-last-session-id"></a><code>get-last-session-id</code></h4>
<pre><code class="language-clojure">(copilot/get-last-session-id client)
</code></pre>
<p>Get the ID of the most recently updated session.</p>
<h4><a href="#get-foreground-session-id" id="get-foreground-session-id"></a><code>get-foreground-session-id</code></h4>
<pre><code class="language-clojure">(copilot/get-foreground-session-id client)
</code></pre>
<p>Get the foreground session ID. Returns the session ID or nil. Only applicable in TUI+server mode.</p>
<h4><a href="#set-foreground-session-id" id="set-foreground-session-id"></a><code>set-foreground-session-id!</code></h4>
<pre><code class="language-clojure">(copilot/set-foreground-session-id! client session-id)
</code></pre>
<p>Set the foreground session. Requests the TUI to switch to displaying the specified session. Only applicable in TUI+server mode.</p>
<hr />
<h2><a href="#copilotsession" id="copilotsession"></a>CopilotSession</h2>
<p>Represents a single conversation session.</p>
<h3><a href="#methods" id="methods"></a>Methods</h3>
<h4><a href="#send" id="send"></a><code>send!</code></h4>
<pre><code class="language-clojure">(copilot/send! session options)
</code></pre>
<p>Send a message to the session. Returns immediately with the message ID.</p>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr><th> Key </th><th> Type </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:prompt</code> </td><td> string </td><td> The message/prompt to send </td></tr>
<tr><td> <code>:attachments</code> </td><td> vector </td><td> File attachments (see below) </td></tr>
<tr><td> <code>:mode</code> </td><td> keyword </td><td> <code>:enqueue</code> or <code>:immediate</code> </td></tr>
</tbody>
</table>
<p><strong>Attachment types:</strong></p>
<table>
<thead>
<tr><th> Type </th><th> Required Keys </th><th> Optional Keys </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:file</code> </td><td> <code>:type</code>, <code>:path</code> </td><td> <code>:display-name</code> </td><td> File attachment </td></tr>
<tr><td> <code>:directory</code> </td><td> <code>:type</code>, <code>:path</code> </td><td> <code>:display-name</code> </td><td> Directory attachment </td></tr>
<tr><td> <code>:selection</code> </td><td> <code>:type</code>, <code>:file-path</code>, <code>:display-name</code> </td><td> <code>:selection-range</code>, <code>:text</code> </td><td> Code selection attachment </td></tr>
</tbody>
</table>
<p>Selection range is a map with <code>:start</code> and <code>:end</code> positions, each containing <code>:line</code> and <code>:character</code>:</p>
<pre><code class="language-clojure">(copilot/send! session
  {:prompt "Explain this code"
   :attachments [{:type :selection
                  :file-path "/path/to/file.clj"
                  :display-name "my-fn"
                  :selection-range {:start {:line 10 :character 0}
                                   :end {:line 25 :character 0}}
                  :text "(defn my-fn [...] ...)"}]})
</code></pre>
<h4><a href="#send-and-wait" id="send-and-wait"></a><code>send-and-wait!</code></h4>
<pre><code class="language-clojure">(copilot/send-and-wait! session options)
(copilot/send-and-wait! session options timeout-ms)
</code></pre>
<p>Send a message and block until the session becomes idle. Returns the final assistant message event. Default timeout is <code>300000</code> ms (5 minutes).</p>
<h4><a href="#send-async" id="send-async"></a><code>send-async</code></h4>
<pre><code class="language-clojure">(copilot/send-async session options)
</code></pre>
<p>Send a message and return a core.async channel that receives all events for this message, closing when idle. Supports <code>:timeout-ms</code> in options (default: <code>300000</code>) to force cleanup on long-running requests.</p>
<h4><a href="#send-async-with-id" id="send-async-with-id"></a><code>send-async-with-id</code></h4>
<pre><code class="language-clojure">(copilot/send-async-with-id session options)
</code></pre>
<p>Send a message and return <code>{:message-id :events-ch}</code> for correlating responses. Supports <code>:timeout-ms</code> in options (default: <code>300000</code>).</p>
<h4><a href="#send" id="send"></a><code>&lt;send!</code></h4>
<pre><code class="language-clojure">(copilot/&lt;send! session options)
</code></pre>
<p>Async equivalent of <code>send-and-wait!</code> for use inside <code>go</code> blocks. Returns a channel that yields the final content string. Supports <code>:timeout-ms</code> in options (default: <code>300000</code>).</p>
<h4><a href="#events" id="events"></a><code>events</code></h4>
<pre><code class="language-clojure">(copilot/events session)
</code></pre>
<p>Get the core.async <code>mult</code> for session events. Use <code>tap</code> to subscribe:</p>
<pre><code class="language-clojure">(let [ch (chan 100)]
  (tap (copilot/events session) ch)
  (go-loop []
    (when-let [event (&lt;! ch)]
      (println event)
      (recur))))
</code></pre>
<h4><a href="#events-chan" id="events-chan"></a><code>events-&gt;chan</code></h4>
<pre><code class="language-clojure">(copilot/events-&gt;chan session {:buffer 256
                               :xf (filter #(= :copilot/assistant.message (:type %)))})
</code></pre>
<p>Subscribe to session events with optional buffer size and transducer.</p>
<h4><a href="#subscribe-events" id="subscribe-events"></a><code>subscribe-events</code></h4>
<pre><code class="language-clojure">(copilot/subscribe-events session)
</code></pre>
<p>Subscribe to session events. Returns a channel (buffer size 1024) that receives events. This is a convenience wrapper around <code>(tap (copilot/events session) ch)</code>.</p>
<h5><a href="#event-drop-behavior" id="event-drop-behavior"></a>Event Drop Behavior</h5>
<p>Session events are delivered via core.async <code>mult</code>. When <code>mult</code> receives an event, it attempts to <code>put!</code> to each subscriber’s channel. <strong>If a subscriber’s buffer is full at that moment, that specific event is silently dropped for that subscriber only.</strong></p>
<p>Key points: - <strong>Per-subscriber</strong>: Each subscriber is independent. If subscriber A’s buffer is full but B has space, only A misses the event. - <strong>Per-event</strong>: Only the event that arrived when the buffer was full is dropped. Earlier events already in the buffer are not affected. - <strong>Silent</strong>: No error, warning, or indication that a drop occurred. - <strong>Not recoverable</strong>: The dropped event is gone for that subscriber.</p>
<p>With the default 1024 buffer, drops are unlikely unless a subscriber completely stops reading. For most use cases, this is not a concern.</p>
<h4><a href="#unsubscribe-events" id="unsubscribe-events"></a><code>unsubscribe-events</code></h4>
<pre><code class="language-clojure">(copilot/unsubscribe-events session ch)
</code></pre>
<p>Unsubscribe a channel from session events.</p>
<h4><a href="#abort" id="abort"></a><code>abort!</code></h4>
<pre><code class="language-clojure">(copilot/abort! session)
</code></pre>
<p>Abort the currently processing message.</p>
<h4><a href="#get-messages" id="get-messages"></a><code>get-messages</code></h4>
<pre><code class="language-clojure">(copilot/get-messages session)
</code></pre>
<p>Get all events/messages from this session.</p>
<h4><a href="#destroy" id="destroy"></a><code>destroy!</code></h4>
<pre><code class="language-clojure">(copilot/destroy! session)
</code></pre>
<p>Destroy the session and free resources.</p>
<h4><a href="#session-id" id="session-id"></a><code>session-id</code></h4>
<pre><code class="language-clojure">(copilot/session-id session)
</code></pre>
<p>Get the session’s unique identifier.</p>
<h4><a href="#workspace-path" id="workspace-path"></a><code>workspace-path</code></h4>
<pre><code class="language-clojure">(copilot/workspace-path session)
</code></pre>
<p>Get the session workspace path when provided by the CLI (may be nil).</p>
<h4><a href="#session-config" id="session-config"></a><code>session-config</code></h4>
<pre><code class="language-clojure">(copilot/session-config session)
;; =&gt; {:model "gpt-5.2", :streaming? true, :reasoning-effort "high", ...}
</code></pre>
<p>Get the configuration that was used to create this session.</p>
<h4><a href="#client" id="client"></a><code>client</code></h4>
<pre><code class="language-clojure">(copilot/client session)
</code></pre>
<p>Get the client that owns this session.</p>
<hr />
<h2><a href="#event-types" id="event-types"></a>Event Types</h2>
<p>Sessions emit various events during processing. All event types are namespaced keywords prefixed with <code>copilot/</code>.</p>
<h3><a href="#exported-constants" id="exported-constants"></a>Exported Constants</h3>
<pre><code class="language-clojure">;; All event types
copilot/event-types
;; =&gt; #{:copilot/session.idle :copilot/assistant.message ...}

;; Session lifecycle events
copilot/session-events
;; =&gt; #{:copilot/session.start :copilot/session.idle ...}

;; Assistant response events  
copilot/assistant-events
;; =&gt; #{:copilot/assistant.message :copilot/assistant.message_delta ...}

;; Tool execution events
copilot/tool-events
;; =&gt; #{:copilot/tool.execution_start :copilot/tool.execution_complete ...}
</code></pre>
<h3><a href="#event-reference" id="event-reference"></a>Event Reference</h3>
<table>
<thead>
<tr><th> Event Type </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:copilot/session.start</code> </td><td> Session created </td></tr>
<tr><td> <code>:copilot/session.resume</code> </td><td> Session resumed </td></tr>
<tr><td> <code>:copilot/session.error</code> </td><td> Session error occurred </td></tr>
<tr><td> <code>:copilot/session.idle</code> </td><td> Session finished processing </td></tr>
<tr><td> <code>:copilot/session.info</code> </td><td> Informational session update </td></tr>
<tr><td> <code>:copilot/session.model_change</code> </td><td> Session model changed </td></tr>
<tr><td> <code>:copilot/session.handoff</code> </td><td> Session handed off to another agent </td></tr>
<tr><td> <code>:copilot/session.usage_info</code> </td><td> Token usage information </td></tr>
<tr><td> <code>:copilot/session.truncation</code> </td><td> Context window truncated </td></tr>
<tr><td> <code>:copilot/session.snapshot_rewind</code> </td><td> Session state rolled back </td></tr>
<tr><td> <code>:copilot/session.compaction_start</code> </td><td> Context compaction started (infinite sessions) </td></tr>
<tr><td> <code>:copilot/session.compaction_complete</code> </td><td> Context compaction completed (infinite sessions) </td></tr>
<tr><td> <code>:copilot/user.message</code> </td><td> User message added </td></tr>
<tr><td> <code>:copilot/pending_messages.modified</code> </td><td> Pending message queue updated </td></tr>
<tr><td> <code>:copilot/assistant.turn_start</code> </td><td> Assistant turn started </td></tr>
<tr><td> <code>:copilot/assistant.intent</code> </td><td> Assistant intent update </td></tr>
<tr><td> <code>:copilot/assistant.reasoning</code> </td><td> Model reasoning (if supported) </td></tr>
<tr><td> <code>:copilot/assistant.reasoning_delta</code> </td><td> Streaming reasoning chunk </td></tr>
<tr><td> <code>:copilot/assistant.message</code> </td><td> Complete assistant response </td></tr>
<tr><td> <code>:copilot/assistant.message_delta</code> </td><td> Streaming response chunk </td></tr>
<tr><td> <code>:copilot/assistant.turn_end</code> </td><td> Assistant turn completed </td></tr>
<tr><td> <code>:copilot/assistant.usage</code> </td><td> Token usage for this turn </td></tr>
<tr><td> <code>:copilot/abort</code> </td><td> Current message aborted </td></tr>
<tr><td> <code>:copilot/tool.user_requested</code> </td><td> Tool execution requested by user </td></tr>
<tr><td> <code>:copilot/tool.execution_start</code> </td><td> Tool execution started </td></tr>
<tr><td> <code>:copilot/tool.execution_progress</code> </td><td> Tool execution progress update </td></tr>
<tr><td> <code>:copilot/tool.execution_partial_result</code> </td><td> Tool execution partial result </td></tr>
<tr><td> <code>:copilot/tool.execution_complete</code> </td><td> Tool execution completed </td></tr>
<tr><td> <code>:copilot/subagent.started</code> </td><td> Subagent started </td></tr>
<tr><td> <code>:copilot/subagent.completed</code> </td><td> Subagent completed </td></tr>
<tr><td> <code>:copilot/subagent.failed</code> </td><td> Subagent failed </td></tr>
<tr><td> <code>:copilot/subagent.selected</code> </td><td> Subagent selected </td></tr>
<tr><td> <code>:copilot/hook.start</code> </td><td> Hook invocation started </td></tr>
<tr><td> <code>:copilot/hook.end</code> </td><td> Hook invocation finished </td></tr>
<tr><td> <code>:copilot/system.message</code> </td><td> System message emitted </td></tr>
</tbody>
</table>
<h3><a href="#example-handling-events" id="example-handling-events"></a>Example: Handling Events</h3>
<pre><code class="language-clojure">(copilot/with-client-session [session {:streaming? true}]
  (let [ch (chan 256)]
    (tap (copilot/events session) ch)
    (go-loop []
      (when-let [event (&lt;! ch)]
        (case (:type event)
          :copilot/assistant.message_delta
          (print (get-in event [:data :delta-content]))
          
          :copilot/session.usage_info
          (println "Tokens:" (get-in event [:data :current-tokens]))
          
          :copilot/session.idle
          (println "\nDone!")
          
          nil)
        (recur)))
    (copilot/send! session {:prompt "Hello"})))
</code></pre>
<hr />
<h2><a href="#streaming" id="streaming"></a>Streaming</h2>
<p>Enable streaming to receive assistant response chunks as they’re generated:</p>
<pre><code class="language-clojure">(def session (copilot/create-session client
               {:model "gpt-5.2"
                :streaming? true}))

(let [ch (chan 100)]
  (tap (copilot/events session) ch)
  (go-loop []
    (when-let [event (&lt;! ch)]
      (case (:type event)
        :copilot/assistant.message_delta
          ;; Streaming chunk - print incrementally
          (print (get-in event [:data :delta-content]))

        :copilot/assistant.reasoning_delta
          ;; Streaming reasoning (model-dependent). Send to stderr.
          (binding [*out* *err*]
            (print (get-in event [:data :delta-content])))

        :copilot/assistant.reasoning
          (binding [*out* *err*]
            (println "\n--- Final Reasoning ---")
            (println (get-in event [:data :content])))

        :copilot/assistant.message
          ;; Final complete message
          (println "\n--- Final ---")
          (println (get-in event [:data :content]))

        nil)
      (recur))))

(copilot/send! session {:prompt "Solve a logic puzzle and show your reasoning."})
</code></pre>
<p>When <code>:streaming? true</code>: - <code>:copilot/assistant.message_delta</code> events contain incremental text in <code>:delta-content</code> - <code>:copilot/assistant.reasoning_delta</code> events contain incremental reasoning in <code>:delta-content</code> (model-dependent) - Accumulate delta values to build the full response progressively - The final <code>:copilot/assistant.message</code> event always contains the complete content</p>
<hr />
<h2><a href="#advanced-usage" id="advanced-usage"></a>Advanced Usage</h2>
<h3><a href="#manual-server-control" id="manual-server-control"></a>Manual Server Control</h3>
<pre><code class="language-clojure">(def client (copilot/client {:auto-start? false}))

;; Start manually
(copilot/start! client)

;; Use client...

;; Stop manually
(copilot/stop! client)
</code></pre>
<h3><a href="#tools" id="tools"></a>Tools</h3>
<p>Let the CLI call back into your process when the model needs capabilities you provide:</p>
<pre><code class="language-clojure">(def lookup-tool
  (copilot/define-tool "lookup_issue"
    {:description "Fetch issue details from our tracker"
     :parameters {:type "object"
                  :properties {:id {:type "string"
                                    :description "Issue identifier"}}
                  :required ["id"]}
     :handler (fn [{:keys [id]} invocation]
                (let [issue (fetch-issue id)]
                  (copilot/result-success issue)))}))

(def session (copilot/create-session client
               {:model "gpt-5.2"
                :tools [lookup-tool]}))
</code></pre>
<p>When Copilot invokes <code>lookup_issue</code>, the SDK automatically runs your handler and responds to the CLI.</p>
<p><strong>Handler return values:</strong></p>
<table>
<thead>
<tr><th> Return Type </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> String </td><td> Automatically wrapped as success result </td></tr>
<tr><td> Map with <code>:result-type</code> </td><td> Full control over result metadata </td></tr>
<tr><td> core.async channel </td><td> Async result (yields string or map) </td></tr>
</tbody>
</table>
<p><strong>Result helpers:</strong></p>
<pre><code class="language-clojure">(copilot/result-success "It worked!")
(copilot/result-failure "It failed" "error details")
(copilot/result-denied "Permission denied")
(copilot/result-rejected "Invalid parameters")
</code></pre>
<h3><a href="#system-message-customization" id="system-message-customization"></a>System Message Customization</h3>
<p>Control the system prompt:</p>
<pre><code class="language-clojure">(def session (copilot/create-session client
               {:model "gpt-5.2"
                :system-message
                  {:content "
&lt;workflow_rules&gt;
- Always check for security vulnerabilities
- Suggest performance improvements when applicable
&lt;/workflow_rules&gt;
"}}))
</code></pre>
<p>The SDK auto-injects environment context, tool instructions, and security guardrails. Your <code>:content</code> is appended after SDK-managed sections.</p>
<p>For full control (removes all guardrails), use <code>:mode :replace</code>:</p>
<pre><code class="language-clojure">(copilot/create-session client
  {:model "gpt-5.2"
   :system-message {:mode :replace
                    :content "You are a helpful assistant."}})
</code></pre>
<h3><a href="#config-directory-and-skills" id="config-directory-and-skills"></a>Config Directory and Skills</h3>
<p><code>config-dir</code> overrides where the CLI reads its config and state (e.g., <code>~/.copilot</code>). It does not define custom agents. Custom agents are provided via <code>:custom-agents</code>.</p>
<pre><code class="language-clojure">(def session (copilot/create-session client
               {:model "gpt-5.2"
                :config-dir "/tmp/copilot-config"
                :skill-directories ["/path/to/skills" "/opt/team-skills"]
                :disabled-skills ["legacy-skill" "experimental-skill"]}))
</code></pre>
<h3><a href="#large-tool-output-handling-experimental" id="large-tool-output-handling-experimental"></a>Large Tool Output Handling (Experimental)</h3>
<blockquote>
<p><strong>Note:</strong> This is a CLI protocol feature not exposed in the official <code>@github/copilot-sdk</code>. The <code>outputDir</code> and <code>maxSizeBytes</code> settings may be ignored by some CLI versions due to a known issue where session-level config is not applied during <code>session.send</code> execution. The CLI’s default behavior (30KB threshold, system tmpdir) applies regardless.</p>
</blockquote>
<p>Configure how large tool outputs are handled before being sent back to the model:</p>
<pre><code class="language-clojure">(def session (copilot/create-session client
               {:model "gpt-5.2"
                :large-output {:enabled true
                               :max-size-bytes 65536
                               :output-dir "/tmp/copilot-tool-output"}}))
</code></pre>
<p>When a tool output exceeds the configured size, the CLI writes the full output to a temp file, and the tool result delivered to the model contains a short message with the file path and preview. You can see this message in <code>:tool.execution_complete</code> events:</p>
<pre><code class="language-clojure">(let [events (copilot/subscribe-events session)]
  (go-loop []
    (when-let [event (&lt;! events)]
        (when (= :tool.execution_complete (:type event))
          (when-let [content (get-in event [:data :result :content])]
            (println "Tool output message:\n" content)))
      (recur))))
</code></pre>
<p>Note: large output handling is applied by the CLI for built-in tools (like the shell tool). For external tools you define in the SDK, consider handling oversized outputs yourself (e.g., write to a file and return a short preview).</p>
<h3><a href="#infinite-sessions" id="infinite-sessions"></a>Infinite Sessions</h3>
<p>Infinite sessions enable automatic context compaction, allowing conversations to continue beyond the model’s context window limit. When the context approaches capacity, the CLI automatically compacts older messages while preserving important context.</p>
<pre><code class="language-clojure">;; Enable with defaults (enabled by default)
(def session (copilot/create-session client
               {:model "gpt-5.2"}))

;; Explicit configuration
(def session (copilot/create-session client
               {:model "gpt-5.2"
                :infinite-sessions {:enabled true
                                    :background-compaction-threshold 0.80
                                    :buffer-exhaustion-threshold 0.95}}))

;; Disable infinite sessions
(def session (copilot/create-session client
               {:model "gpt-5.2"
                :infinite-sessions {:enabled false}}))
</code></pre>
<p><strong>Configuration options:</strong></p>
<table>
<thead>
<tr><th> Key </th><th> Type </th><th> Default </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> <code>:enabled</code> </td><td> boolean </td><td> <code>true</code> </td><td> Enable infinite sessions </td></tr>
<tr><td> <code>:background-compaction-threshold</code> </td><td> number </td><td> <code>0.80</code> </td><td> Context utilization (0.0-1.0) at which background compaction starts </td></tr>
<tr><td> <code>:buffer-exhaustion-threshold</code> </td><td> number </td><td> <code>0.95</code> </td><td> Context utilization (0.0-1.0) at which session blocks until compaction completes </td></tr>
</tbody>
</table>
<p><strong>How it works:</strong></p>
<ol>
<li>When context reaches the background threshold (default 80%), compaction starts asynchronously</li>
<li>The session continues processing while compaction runs in the background</li>
<li>If context reaches the buffer exhaustion threshold (default 95%), the session blocks until compaction completes</li>
<li>Compaction preserves essential context while removing older, less relevant messages</li>
</ol>
<p><strong>Compaction events:</strong></p>
<p>Sessions emit <code>:session.compaction_start</code> and <code>:session.compaction_complete</code> events during compaction:</p>
<pre><code class="language-clojure">(let [ch (copilot/subscribe-events session)]
  (go-loop []
    (when-let [event (&lt;! ch)]
      (case (:type event)
        :session.compaction_start
        (println "Compaction started...")

        :session.compaction_complete
        (println "Compaction complete")

        nil)
      (recur))))
</code></pre>
<h3><a href="#permission-handling" id="permission-handling"></a>Permission Handling</h3>
<p>When the CLI needs approval (e.g., shell or file write), it sends a JSON-RPC <code>permission.request</code> to the SDK. Your <code>:on-permission-request</code> callback must return a map compatible with the permission result payload; the SDK wraps this into the JSON-RPC response as <code>{:result &lt;your-map&gt;}</code>:</p>
<p>The <code>permission_bash.clj</code> example demonstrates both an allowed and a denied shell command and prints the full permission request payload so you can inspect fields like <code>:full-command-text</code>, <code>:commands</code>, and <code>:possible-paths</code>.</p>
<pre><code class="language-clojure">;; Approve
{:kind :approved}

;; Deny with rules
{:kind :denied-by-rules
 :rules [{:kind "shell" :argument "echo hi"}]}

;; Deny without interactive approval
{:kind :denied-no-approval-rule-and-could-not-request-from-user}

;; Deny after user interaction (optional feedback)
{:kind :denied-interactively-by-user :feedback "Not allowed"}
</code></pre>
<h3><a href="#user-input-handling" id="user-input-handling"></a>User Input Handling</h3>
<p>When the agent needs input from the user (via <code>ask_user</code> tool), the <code>:on-user-input-request</code> handler is called. Return a response map with the user’s input:</p>
<pre><code class="language-clojure">(def session (copilot/create-session client
               {:model "gpt-5.2"
                :on-user-input-request
                (fn [request invocation]
                  ;; request contains {:question "..." :choices [...] :allow-freeform true/false}
                  (println "Agent asks:" (:question request))
                  (when-let [choices (:choices request)]
                    (println "Choices:" choices))
                  ;; Return user's response
                  ;; :answer is required, :was-freeform defaults to true
                  {:answer (read-line)
                   :was-freeform true})}))
</code></pre>
<p>The request map includes: - <code>:question</code> - The question being asked - <code>:choices</code> - Optional list of choices for multiple choice questions - <code>:allow-freeform</code> - Whether freeform text input is allowed</p>
<p>The response map should include: - <code>:answer</code> - The user’s answer (string, required). <code>:response</code> is also accepted for convenience. - <code>:was-freeform</code> - Whether the answer was freeform (boolean, defaults to true)</p>
<h3><a href="#session-hooks" id="session-hooks"></a>Session Hooks</h3>
<p>Lifecycle hooks allow custom logic at various points during the session:</p>
<pre><code class="language-clojure">(def session (copilot/create-session client
               {:model "gpt-5.2"
                :hooks
                {:on-pre-tool-use
                 (fn [input invocation]
                   ;; Called before each tool execution
                   ;; input contains {:tool-name "..." :arguments {...}}
                   (println "About to use tool:" (:tool-name input))
                   ;; Return nil to proceed, or a modified input map
                   nil)

                 :on-post-tool-use
                 (fn [input invocation]
                   ;; Called after each tool execution
                   ;; input contains {:tool-name "..." :result {...}}
                   (println "Tool completed:" (:tool-name input))
                   nil)

                 :on-user-prompt-submitted
                 (fn [input invocation]
                   ;; Called when user sends a prompt
                   (println "User prompt:" (:prompt input))
                   nil)

                 :on-session-start
                 (fn [input invocation]
                   (println "Session started")
                   nil)

                 :on-session-end
                 (fn [input invocation]
                   (println "Session ended")
                   nil)

                 :on-error-occurred
                 (fn [input invocation]
                   (println "Error:" (:error input))
                   nil)}}))
</code></pre>
<p>All hooks receive an <code>input</code> map (contents vary by hook type) and an <code>invocation</code> map containing <code>{:session-id ...}</code>. Hooks may return <code>nil</code> to proceed normally, or in some cases return a modified value.</p>
<h3><a href="#reasoning-effort" id="reasoning-effort"></a>Reasoning Effort</h3>
<p>For models that support reasoning (like o1), you can control the reasoning effort level:</p>
<pre><code class="language-clojure">;; Check model capabilities
(let [models (copilot/list-models client)]
  (doseq [m models
          :when (:supports-reasoning-effort m)]
    (println (:name m) "supports reasoning:"
             (:supported-reasoning-efforts m)
             "default:" (:default-reasoning-effort m))))

;; Create session with reasoning effort
(def session (copilot/create-session client
               {:model "o1"
                :reasoning-effort "high"})) ; "low", "medium", "high", or "xhigh"
</code></pre>
<h3><a href="#multiple-sessions" id="multiple-sessions"></a>Multiple Sessions</h3>
<pre><code class="language-clojure">(def session1 (copilot/create-session client {:model "gpt-5.2"}))
(def session2 (copilot/create-session client {:model "claude-sonnet-4.5"}))

;; Both sessions are independent
(copilot/send-and-wait! session1 {:prompt "Hello from session 1"})
(copilot/send-and-wait! session2 {:prompt "Hello from session 2"})
</code></pre>
<h3><a href="#file-attachments" id="file-attachments"></a>File Attachments</h3>
<pre><code class="language-clojure">;; File attachment
(copilot/send! session
  {:prompt "Analyze this file"
   :attachments [{:type :file
                  :path "/path/to/file.clj"
                  :display-name "My File"}]})

;; Selection attachment (code range)
(copilot/send! session
  {:prompt "What does this function do?"
   :attachments [{:type :selection
                  :file-path "/path/to/file.clj"
                  :display-name "my-function"
                  :selection-range {:start {:line 10 :character 0}
                                   :end {:line 25 :character 0}}
                  :text "(defn my-function [...] ...)"}]})
</code></pre>
<h3><a href="#connecting-to-external-server" id="connecting-to-external-server"></a>Connecting to External Server</h3>
<pre><code class="language-clojure">;; Connect to an existing CLI server (no process spawned)
(def client (copilot/client {:cli-url "localhost:8080"}))
(copilot/start! client)
</code></pre>
<hr />
<h2><a href="#error-handling" id="error-handling"></a>Error Handling</h2>
<pre><code class="language-clojure">(try
  (let [session (copilot/create-session client)]
    (copilot/send! session {:prompt "Hello"}))
  (catch Exception e
    (println "Error:" (ex-message e))))
</code></pre>
</div></div></div></body></html>