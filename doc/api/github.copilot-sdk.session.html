<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>github.copilot-sdk.session documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="API.html"><div class="inner"><span>API Reference</span></div></a></li><li class="depth-1 "><a href="byok.html"><div class="inner"><span>BYOK (Bring Your Own Key)</span></div></a></li><li class="depth-1 "><a href="debugging.html"><div class="inner"><span>MCP Server Debugging Guide</span></div></a></li><li class="depth-1 "><a href="getting-started.html"><div class="inner"><span>Getting Started with the Copilot SDK for Clojure</span></div></a></li><li class="depth-1 "><a href="index.html"><div class="inner"><span>Authentication</span></div></a></li><li class="depth-1 "><a href="index.html"><div class="inner"><span>Documentation</span></div></a></li><li class="depth-1 "><a href="overview.html"><div class="inner"><span>Using MCP Servers with the Copilot SDK for Clojure</span></div></a></li><li class="depth-1 "><a href="style.html"><div class="inner"><span>Documentation Style Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>github</span></div></div></li><li class="depth-2"><a href="github.copilot-sdk.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>copilot-sdk</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.helpers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>helpers</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.instrument.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>instrument</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.logging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>logging</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.process.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>process</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li><li class="depth-3 branch current"><a href="github.copilot-sdk.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.specs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specs</span></div></a></li><li class="depth-3 branch"><a href="github.copilot-sdk.tools.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tools</span></div></a></li><li class="depth-3"><a href="github.copilot-sdk.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="github.copilot-sdk.session.html#var-.3Csend.21"><div class="inner"><span>&lt;send!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-abort.21"><div class="inner"><span>abort!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-config"><div class="inner"><span>config</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-create-session"><div class="inner"><span>create-session</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-destroy.21"><div class="inner"><span>destroy!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-dispatch-event.21"><div class="inner"><span>dispatch-event!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-events"><div class="inner"><span>events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-events-.3Echan"><div class="inner"><span>events-&gt;chan</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-get-messages"><div class="inner"><span>get-messages</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-handle-hooks-invoke.21"><div class="inner"><span>handle-hooks-invoke!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-handle-permission-request.21"><div class="inner"><span>handle-permission-request!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-handle-tool-call.21"><div class="inner"><span>handle-tool-call!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-handle-user-input-request.21"><div class="inner"><span>handle-user-input-request!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-send.21"><div class="inner"><span>send!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-send-and-wait.21"><div class="inner"><span>send-and-wait!</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-send-async"><div class="inner"><span>send-async</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-send-async-with-id"><div class="inner"><span>send-async-with-id</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-session-id"><div class="inner"><span>session-id</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-subscribe-events"><div class="inner"><span>subscribe-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-unsubscribe-events"><div class="inner"><span>unsubscribe-events</span></div></a></li><li class="depth-1"><a href="github.copilot-sdk.session.html#var-workspace-path"><div class="inner"><span>workspace-path</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">github.copilot-sdk.session</h1><div class="doc"><div class="markdown"><p>CopilotSession - session operations using centralized client state.</p>
<p>All session state is stored in the client’s :state atom under: - <a href=":sessions session-id">:sessions session-id</a> -&gt; {:tool-handlers {} :permission-handler nil :destroyed? false :workspace-path nil} - <a href=":session-io session-id">:session-io session-id</a> -&gt; {:event-chan :event-mult}</p>
<p>Functions take client + session-id, accessing state through the client.</p>
</div></div><div class="public anchor" id="var-.3Csend.21"><h3>&lt;send!</h3><div class="usage"><code>(&lt;send! session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message and return a channel that delivers the final content string. This is the async equivalent of send-and-wait! - use inside go blocks.</p>
<p>Options: - :timeout-ms   - Timeout in milliseconds (default: 300000, set to nil to disable)</p>
<p>The returned channel delivers a single value (the response content) then closes.</p>
</div></div></div><div class="public anchor" id="var-abort.21"><h3>abort!</h3><div class="usage"><code>(abort! session)</code></div><div class="doc"><div class="markdown"><p>Abort the currently processing message in this session.</p>
</div></div></div><div class="public anchor" id="var-config"><h3>config</h3><div class="usage"><code>(config session)</code></div><div class="doc"><div class="markdown"><p>Get the session configuration that was used to create this session. Returns the user-provided config. Note: This reflects what was requested, not necessarily what the server is using. The session.start event contains the actual selectedModel if validation is needed.</p>
</div></div></div><div class="public anchor" id="var-create-session"><h3>create-session</h3><div class="usage"><code>(create-session client session-id {:keys [tools on-permission-request on-user-input-request hooks workspace-path config]})</code></div><div class="doc"><div class="markdown"><p>Create a new session. Internal use - called by client. Initializes session state in client’s atom and returns a CopilotSession handle.</p>
</div></div></div><div class="public anchor" id="var-destroy.21"><h3>destroy!</h3><div class="usage"><code>(destroy! session)</code><code>(destroy! client session-id)</code></div><div class="doc"><div class="markdown"><p>Destroy the session and free resources. Can be called with either a CopilotSession handle or (client, session-id).</p>
</div></div></div><div class="public anchor" id="var-dispatch-event.21"><h3>dispatch-event!</h3><div class="usage"><code>(dispatch-event! client session-id event)</code></div><div class="doc"><div class="markdown"><p>Dispatch an event to all subscribers via the mult. Called by client notification router. Events are dropped (with debug log) if the session event buffer is full.</p>
</div></div></div><div class="public anchor" id="var-events"><h3>events</h3><div class="usage"><code>(events session)</code></div><div class="doc"><div class="markdown"><p>Get the event mult for this session. Use tap to subscribe:</p>
<p>(let <a href="ch (chan 100)">ch (chan 100)</a> (tap (events session) ch) (go-loop [] (when-let <a href="event (&lt;! ch)">event (&lt;! ch)</a> (println event) (recur))))</p>
<p>Remember to untap and close your channel when done.</p>
</div></div></div><div class="public anchor" id="var-events-.3Echan"><h3>events-&gt;chan</h3><div class="usage"><code>(events-&gt;chan session)</code><code>(events-&gt;chan session {:keys [buffer xf], :or {buffer 1024}})</code></div><div class="doc"><div class="markdown"><p>Subscribe to session events with options.</p>
<p>Options: - :buffer - Channel buffer size (default 1024) - :xf     - Transducer applied to events</p>
<p>Drop behavior: If this subscriber’s channel buffer is full when mult tries to deliver an event, that specific event is silently dropped for this subscriber only. Other subscribers with available buffer space still receive the event.</p>
</div></div></div><div class="public anchor" id="var-get-messages"><h3>get-messages</h3><div class="usage"><code>(get-messages session)</code></div><div class="doc"><div class="markdown"><p>Get all events/messages from this session’s history.</p>
</div></div></div><div class="public anchor" id="var-handle-hooks-invoke.21"><h3>handle-hooks-invoke!</h3><div class="usage"><code>(handle-hooks-invoke! client session-id hook-type input)</code></div><div class="doc"><div class="markdown"><p>Handle an incoming hooks invocation. Returns a channel with the result. PR #269 feature.</p>
</div></div></div><div class="public anchor" id="var-handle-permission-request.21"><h3>handle-permission-request!</h3><div class="usage"><code>(handle-permission-request! client session-id request)</code></div><div class="doc"><div class="markdown"><p>Handle an incoming permission request. Returns a channel with the result.</p>
</div></div></div><div class="public anchor" id="var-handle-tool-call.21"><h3>handle-tool-call!</h3><div class="usage"><code>(handle-tool-call! client session-id tool-call-id tool-name arguments)</code></div><div class="doc"><div class="markdown"><p>Handle an incoming tool call request. Returns a channel with the result wrapper.</p>
</div></div></div><div class="public anchor" id="var-handle-user-input-request.21"><h3>handle-user-input-request!</h3><div class="usage"><code>(handle-user-input-request! client session-id request)</code></div><div class="doc"><div class="markdown"><p>Handle an incoming user input request (ask_user). Returns a channel with the result. PR #269 feature.</p>
<p>The handler should return a map with :answer (string) and optionally :was-freeform (boolean). For backwards compatibility, :response is also accepted as an alias for :answer.</p>
</div></div></div><div class="public anchor" id="var-send.21"><h3>send!</h3><div class="usage"><code>(send! session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message to the session. Returns the message ID immediately (fire-and-forget).</p>
<p>Options: - :prompt       - The message text (required) - :attachments  - Vector of attachments (file/directory/selection) - :mode         - :enqueue (default) or :immediate</p>
</div></div></div><div class="public anchor" id="var-send-and-wait.21"><h3>send-and-wait!</h3><div class="usage"><code>(send-and-wait! session opts)</code><code>(send-and-wait! session opts timeout-ms)</code></div><div class="doc"><div class="markdown"><p>Send a message and wait until the session becomes idle. Returns the final assistant message event, or nil if none received. Serialized per session to avoid mixing concurrent sends.</p>
<p>Options: same as send!</p>
<p>Additional options: - :timeout-ms   - Timeout in milliseconds (default: 300000)</p>
</div></div></div><div class="public anchor" id="var-send-async"><h3>send-async</h3><div class="usage"><code>(send-async session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message and return a channel that receives events until session.idle. The channel closes after session.idle or session.error. Serialized per session to avoid mixing concurrent sends.</p>
<p>Options: - :timeout-ms   - Timeout in milliseconds (default: 300000, set to nil to disable)</p>
</div></div></div><div class="public anchor" id="var-send-async-with-id"><h3>send-async-with-id</h3><div class="usage"><code>(send-async-with-id session opts)</code></div><div class="doc"><div class="markdown"><p>Send a message and return {:message-id :events-ch}.</p>
</div></div></div><div class="public anchor" id="var-session-id"><h3>session-id</h3><div class="usage"><code>(session-id session)</code></div><div class="doc"><div class="markdown"><p>Get the session ID.</p>
</div></div></div><div class="public anchor" id="var-subscribe-events"><h3>subscribe-events</h3><div class="usage"><code>(subscribe-events session)</code></div><div class="doc"><div class="markdown"><p>Subscribe to session events. Returns a channel that receives events.</p>
<p>The channel will receive nil (close) when the session is destroyed. For explicit cleanup before session destruction, call unsubscribe-events.</p>
<p>Drop behavior: If this subscriber’s channel buffer is full when mult tries to deliver an event, that specific event is silently dropped for this subscriber only. Other subscribers with available buffer space still receive the event. The returned channel has a buffer of 1024 events which should be sufficient for most use cases.</p>
<p>This is a convenience wrapper around (tap (events session) ch).</p>
</div></div></div><div class="public anchor" id="var-unsubscribe-events"><h3>unsubscribe-events</h3><div class="usage"><code>(unsubscribe-events session ch)</code></div><div class="doc"><div class="markdown"><p>Unsubscribe a channel from session events.</p>
</div></div></div><div class="public anchor" id="var-workspace-path"><h3>workspace-path</h3><div class="usage"><code>(workspace-path session)</code></div><div class="doc"><div class="markdown"><p>Get the session workspace path when provided by the CLI.</p>
</div></div></div></div></body></html>